# Docker Volume

Volumes are the preferred mechanism for persisting data generated by and used by Docker containers. While bind mounts are dependent on the directory structure and OS of the host machine, volumes are completely managed by Docker. Volumes have several advantages over bind mounts:

- Volumes are easier to back up or migrate than bind mounts.
- You can manage volumes using Docker CLI commands or the Docker API.
- Volumes work on both Linux and Windows containers.
- Volumes can be more safely shared among multiple containers.
- Volume drivers let you store volumes on remote hosts or cloud providers, encrypt the contents of volumes, or add other functionality.
- New volumes can have their content pre-populated by a container.
- Volumes on Docker Desktop have much higher performance than bind mounts from Mac and Windows hosts.

In addition, volumes are often a better choice than persisting data in a container's writable layer, because a volume doesn't increase the size of the containers using it, and the volume's contents exist outside the lifecycle of a given container.

![types-of-mounts-volume.webp](Docker%20Volume%201b2aeacbb2998106b1e8f5117c32e3c9/types-of-mounts-volume.webp)

If your container generates non-persistent state data, consider using a tmpfs mount to avoid storing the data anywhere permanently, and to increase the container's performance by avoiding writing into the container's writable layer.

Volumes use `rprivate` bind propagation, and bind propagation isn't configurable for volumes.

## Choose the -v or --mount flag

In general, `--mount` is more explicit and verbose. The biggest difference is that the `-v` syntax combines all the options together in one field, while the `--mount` syntax separates them. Here is a comparison of the syntax for each flag.

If you need to specify volume driver options, you must use `--mount`.

- `v` or `-volume`: Consists of three fields, separated by colon characters (`:`). The fields must be in the correct order, and the meaning of each field isn't immediately obvious.
    - In the case of named volumes, the first field is the name of the volume, and is unique on a given host machine. For anonymous volumes, the first field is omitted.
    - The second field is the path where the file or directory is mounted in the container.
    - The third field is optional, and is a comma-separated list of options, such as `ro`. These options are discussed below.
- `-mount`: Consists of multiple key-value pairs, separated by commas and each consisting of a `<key>=<value>` tuple. The `-mount` syntax is more verbose than `v` or `-volume`, but the order of the keys isn't significant, and the value of the flag is easier to understand.
    - The `type` of the mount, which can be [`bind`](https://docs.docker.com/engine/storage/bind-mounts/), `volume`, or [`tmpfs`](https://docs.docker.com/engine/storage/tmpfs/). This topic discusses volumes, so the type is always `volume`.
    - The `source` of the mount. For named volumes, this is the name of the volume. For anonymous volumes, this field is omitted. Can be specified as `source` or `src`.
    - The `destination` takes as its value the path where the file or directory is mounted in the container. Can be specified as `destination`, `dst`, or `target`.
    - The `volume-subpath` option takes a path to a subdirectory within the volume to mount into the container. The subdirectory must exist in the volume before the volume is mounted to a container. See Mount a volume subdirectory.
    - The `readonly` option, if present, causes the bind mount to be mounted into the container as read-only. Can be specified as `readonly` or `ro`.
    - The `volume-opt` option, which can be specified more than once, takes a key-value pair consisting of the option name and its value.

## Differences between `-v` and `--mount` behavior

As opposed to bind mounts, all options for volumes are available for both `--mount` and `-v` flags.

Volumes used with services, only support `--mount`.

## Create and manage volumes

Unlike a bind mount, you can create and manage volumes outside the scope of any container.

Create a volume:

```bash
docker volume create my-vol
```

List volumes:

```bash
docker volume ls

local               my-vol
```

Inspect a volume:

```bash
docker volume inspect my-vol
[
    {
        "Driver": "local",
        "Labels": {},
        "Mountpoint": "/var/lib/docker/volumes/my-vol/_data",
        "Name": "my-vol",
        "Options": {},
        "Scope": "local"
    }
]
```

Remove a volume:

```bash
docker volume rm my-vol
```

## Start a container with a volume

If you start a container with a volume that doesn't yet exist, Docker creates the volume for you. The following example mounts the volume `myvol2` into `/app/` in the container.

The `-v` and `--mount` examples below produce the same result. You can't run them both unless you remove the `devtest` container and the `myvol2` volume after running the first one.

For `—mount`

```bash
docker run -d \
  --name devtest \
  --mount source=myvol2,target=/app \
  nginx:latest
```

For `-v`

```bash
docker run -d \
  --name devtest \
  -v myvol2:/app \
  nginx:latest
```

Use `docker inspect devtest` to verify that Docker created the volume and it mounted correctly. Look for the `Mounts` section:

```bash
"Mounts": [
    {
        "Type": "volume",
        "Name": "myvol2",
        "Source": "/var/lib/docker/volumes/myvol2/_data",
        "Destination": "/app",
        "Driver": "local",
        "Mode": "",
        "RW": true,
        "Propagation": ""
    }
],
```

This shows that the mount is a volume, it shows the correct source and destination, and that the mount is read-write.

Stop the container and remove the volume. Note volume removal is a separate step.

```bash
docker container stop devtest

docker container rm devtest

docker volume rm myvol2
```

## Use a volume with Docker Compose

The example below shows a single Docker Compose service with a volume:

```yaml
services:
  frontend:
    image: node:lts
    volumes:
      - myapp:/home/node/app
volumes:
  myapp:
```

Running `docker compose up` for the first time creates a volume. Docker reuses the same volume when you run the command subsequently.

You can create a volume directly outside of Compose using `docker volume create` and then reference it inside `compose.yaml` as follows:

```yaml
services:
  frontend:
    image: node:lts
    volumes:
      - myapp:/home/node/app
volumes:
  myapp:
    external: true
```